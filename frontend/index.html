<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Frag Friedrich Barbarossa</title>

<link rel="icon" href="avatar.png" type="image/png">
<link rel="apple-touch-icon" href="avatar.png">
<meta name="theme-color" content="#000000">

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: "Georgia", serif;
    color: white;
  }
  h1 {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    font-size: 2em;
    color: #e0b36b;
    animation: pulse 3s ease-in-out infinite;
  }
  @keyframes pulse {
    0%,100% { opacity: 1; }
    50% { opacity: 0.85; }
  }
  #avatarCanvas { width:100%; height:100%; display:block; }
  #micBtn {
    position:absolute;
    bottom:60px;
    left:50%;
    transform:translateX(-50%);
    width:80px;
    height:80px;
    border-radius:50%;
    border:none;
    background:#222;
    color:white;
    font-size:32px;
    cursor:pointer;
  }
  #micBtn:hover { background:#444; }
  #loading {
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    color:#ccc;
    font-size:1.1em;
    text-align:center;
  }
</style>
</head>

<body>
<h1>Frag Friedrich</h1>
<div id="loading">Avatar wird geladenâ€¦</div>
<canvas id="avatarCanvas"></canvas>
<button id="micBtn">ðŸŽ¤</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
console.log("SCRIPT START");

/* ===============================
   STATE-VARIABLEN + SICHERHEIT
================================ */

// === VISEME-STATE (zentral, exklusiv) ===
let visemeMesh = null;               // wird im GLTF-Loader gesetzt

// Audio / Analyse (Reserve / optional)
let audioCtx, analyser, src;

// === HauptzustÃ¤nde ===
let model, STATE = "idle";
let lastTranscript = "";
let talking = false, greeted = false;
let mouthCooldown = false;
let justFinishedSpeaking = false;
let recRunning = false;

// === Guards (Museums-HÃ¤rtung) ===
let wakeGuard = false;               // blockt ersten Klick nach Sleep
let wakeStabilizing = false;         // blockt Recognition direkt nach Wake
let recognitionHandled = false;      // verhindert doppeltes recognition.onend
let askInProgress = false;           // garantiert nur EIN /ask pro Durchlauf

// === BewegungszustÃ¤nde ===
let frontalFix = true;               // nach Laden: noch nicht frontal
let hmNeigen = false, hmStartTime = 0;
let rising = false, riseStartTime = 0;

// â­ RÃ¼ckkehr nach rechts â€“ nur am ENDE gesteuert!
let toIdlePose = false, toIdleStart = 0;
const toIdleDuration = 3000;

// === Animationszeiten (ms) ===
const hmDuration = 8000;             // Hmmm sehr langsam
const riseDuration = 3000;           // BegrÃ¼ÃŸung / Antwort â†’ frontal

// === Grundposition Avatar ===
let baseRotY = -0.35;                // leicht nach rechts geneigt
let baseRotX = 0.25;
let baseY = 0;

// ðŸ›¡ï¸ NIEMALS gleichzeitig mehrere Bewegungen
function resetMovements() {
  hmNeigen = false;
  rising = false;
  talking = false;
}

/* -----------------------------
   THREE.js SETUP
----------------------------- */

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  30,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 2.8);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("avatarCanvas"),
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000);

/* LICHT â€“ KORREKT */
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(1, 1, 2);
scene.add(dirLight);

const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambLight);

const frontLight = new THREE.PointLight(0xffffff, 0.8);
frontLight.position.set(0, 0.5, 2);
scene.add(frontLight);

/* --------------------------------------------------
   MODEL LADEN + VISEME-MESH FINDEN
   (KLON â€“ Viseme-Version)
-------------------------------------------------- */

// === Viseme-Referenz (global nutzbar) ===
visemeMesh = null;

// === Feste Viseme-Indizes aus Blender ===
const visemeIndex = {
  A: 0,
  E: 1,
  O: 2,
  U: 3,
  M: 4
};

/* --------------------------------------------------
   MODEL LADEN + VISEME-MESH FINDEN
   (KLON â€“ Viseme-Version)
-------------------------------------------------- */

const loader = new THREE.GLTFLoader();
loader.load("./avatar.glb", gltf => {

  model = gltf.scene;
  scene.add(model);

  // --- Viseme-Mesh finden (SkinnedMesh oder Mesh mit MorphTargets) ---
  visemeMesh = null;
  model.traverse(obj => {
    if ((obj.isMesh || obj.isSkinnedMesh) && obj.morphTargetDictionary) {
      console.log("âœ” Viseme-TrÃ¤ger gefunden:", obj.name, obj.morphTargetDictionary);
      if (!visemeMesh) visemeMesh = obj;
    }
  });

  if (!visemeMesh) {
    console.error("âŒ KEIN Viseme-Mesh gefunden â€“ GLB prÃ¼fen!");
  }

  // --- Ladeanzeige aus ---
  document.getElementById("loading").style.display = "none";

  // --- Animation starten (GENAU EINMAL) ---
  animate();
});

/* --------------------------------------------------
   VISEME SETZEN â€“ EXKLUSIV
-------------------------------------------------- */
function setViseme(key, value) {
  if (!visemeMesh || !visemeMesh.morphTargetInfluences) return;

  const idx = visemeIndex[key];
  if (idx === undefined) return;

  // alle Viseme schlieÃŸen
  visemeMesh.morphTargetInfluences.fill(0);

  // Ziel-Visem setzen
  visemeMesh.morphTargetInfluences[idx] = value;
}
/* --------------------------------------------------
   VISEME-LIPSYNC AUS TEXT + TTS
   (SATZZEICHEN-GESTEUERT, OHNE NACHKLAPPERN)
-------------------------------------------------- */

function applyVisemeFromChar(ch) {
  ch = ch.toLowerCase();

  // harte SchlieÃŸer (Konsonanten)
  if ("mpb".includes(ch)) return "M";

  // Vokale
  if ("aÃ¤".includes(ch)) return "A";
  if ("eÃ©iÃ­".includes(ch)) return "E";
  if ("oÃ¶".includes(ch)) return "O";
  if ("uÃ¼".includes(ch)) return "U";

  return null;
}

function isSoftPause(ch) {
  return ",;:".includes(ch);
}

function isHardPause(ch) {
  return ".!?".includes(ch);
}

function speakWithVisemes(text, slow = true) {
  if (!visemeMesh) return;

  /* --- TTS --- */
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "de-DE";
  u.rate = slow ? 0.85 : 1.0;
  if (maleVoice) u.voice = maleVoice;

  let i = 0;
  let lastKey = null;
  const stepMs = slow ? 180 : 150;

  // Start neutral
  setViseme("M", 0);

  const step = () => {
    if (i >= text.length) return;

    const ch = text[i];

    /* --- SATZZEICHEN --- */
    if (isSoftPause(ch)) {
      setViseme("M", 1);
      setTimeout(() => setViseme("M", 0), 140);
      i++;
      setTimeout(step, stepMs + 120);
      return;
    }

    if (isHardPause(ch)) {
      setViseme("M", 1);
      i++;
      setTimeout(() => {
        setViseme("M", 0);
        step();
      }, stepMs + 220);
      return;
    }

    /* --- NORMALE ZEICHEN --- */
    const key = applyVisemeFromChar(ch);

    if (key && key !== lastKey) {
      setViseme(key, 1);
      lastKey = key;
    }

    setTimeout(() => {
      if (key) setViseme(key, 0);
      i++;
      step();
    }, stepMs);
  };

  // Start synchron
  u.onstart = () => step();
  speechSynthesis.speak(u);
}
// ====================================
// ANIMATE â€“ FINAL & STABIL (VISEME-KLON)
// ====================================
function animate() {
  requestAnimationFrame(animate);
  if (!model) return;

  const now = performance.now();
  const frontalY = -Math.PI / 2;               // frontal
  const rightY   = baseRotY - Math.PI / 2;     // Startpose rechts
  const leftY    = frontalY + 0.25;            // Hmmm = leicht links

  // ðŸ§Š Idle-Mundhaltung (VISEME): nur wenn NICHT gesprochen wird
  //    und kein Cooldown / Nachzittern aktiv ist.
  //    Wichtig: NICHT wÃ¤hrend talking -> sonst Ã¼berschreibt animate die Viseme-Steuerung.
  if (!talking && !justFinishedSpeaking && !mouthCooldown) {
    // neutral/geschlossen â€“ kein "Atmen" Ã¼ber Viseme, um Flattern zu vermeiden
    setViseme("M", 0);
  }

  // 0ï¸âƒ£ START: Ausgangsposition (leicht rechts)
  if (frontalFix) {
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, rightY, 0.08);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX, 0.08);
    renderer.render(scene, camera);
    return;
  }

  // 1ï¸âƒ£ GREET / ANTWORTBEGINN â†’ FRONTAL
  if (rising) {
    const t = (now - riseStartTime) / riseDuration;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.06);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.06);
    if (t >= 1) rising = false;
  }

  // 2ï¸âƒ£ HMMM â†’ LANGSAM LINKS
  else if (hmNeigen) {
    const t = Math.min(1, (now - hmStartTime) / hmDuration);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX + 0.25, t);
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, leftY, t);
  }

  // 3ï¸âƒ£ ANTWORT â†’ FRONTAL
  else if (STATE === "answer") {
    model.position.y = baseY + Math.sin(now * 0.0015) * 0.008;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 4ï¸âƒ£ TALKING = SPRICHT â†’ FRONTAL & ATMEN
  else if (talking) {
    model.position.y = baseY + Math.sin(now * 0.0015) * 0.008;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 5ï¸âƒ£ WARTET AUF FRAGE â†’ FRONTAL
  else if (STATE === "listen" || STATE === "greet") {
    model.position.y = baseY + Math.sin(now * 0.0012) * 0.006;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  // 6ï¸âƒ£ ENDE â†’ SANFT ZURÃœCK NACH RECHTS
  else if (STATE === "idle" && !talking && !rising) {
    const breathSpeed = 0.0011 + Math.sin(now * 0.00005) * 0.0004;
    const breathAmp   = 0.006  + Math.sin(now * 0.00008) * 0.003;
    model.position.y  = baseY + Math.sin(now * breathSpeed) * breathAmp;

    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, rightY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX, 0.03);
  }

  // â­ Sehr dezente, wÃ¼rdige Kopf-Driftbewegungen (Kaiser-Version 3.0)
  const driftX = Math.sin(now * 0.0004) * 0.015;   // langsames, kaum sichtbares Nicken
  const driftY = Math.sin(now * 0.0003) * 0.012;   // sehr sanfte Seitbewegung

  // X-Achse â†’ sanft um baseRotX
  model.rotation.x = THREE.MathUtils.lerp(
    model.rotation.x,
    baseRotX + driftX,
    0.02
  );

  // Y-Achse â†’ um fixe Basis (keine Aufschaukelung)
  if (!hmNeigen && !rising) {
    const baseYawForDrift = (STATE === "idle") ? rightY : frontalY;
    const targetYaw = baseYawForDrift + driftY;

    model.rotation.y = THREE.MathUtils.lerp(
      model.rotation.y,
      targetYaw,
      0.02
    );
  }

  renderer.render(scene, camera);
}

/* -----------------------------
   STATE MACHINE â€“ LOGIK (FINAL)
----------------------------- */

let recognition;
if ("webkitSpeechRecognition" in window) {
  recognition = new webkitSpeechRecognition();
  recognition.lang = "de-DE";
  recognition.continuous = false;

  recognition.onresult = e => {
    lastTranscript = e.results[0][0].transcript;
  };

  recognition.onend = () => {

    // ðŸ›¡ï¸ Wake-Stabilizer: Ghost-onend direkt nach Sleep ignorieren
    if (wakeStabilizing) {
      console.warn("â¸ï¸ recognition.onend ignoriert (Wake-Stabilizer)");
      recRunning = false;
      return;
    }

    // ðŸ›¡ï¸ Ghost-onend ohne aktiven Start ignorieren
    if (!recRunning) {
      console.warn("â¸ï¸ recognition.onend ohne recRunning â€“ ignoriert");
      return;
    }

    // ðŸ›¡ï¸ Doppeltes onend verhindern
    if (recognitionHandled) {
      console.warn("ðŸ›‘ recognition.onend doppelt â€“ ignoriert");
      return;
    }
    recognitionHandled = true;

    recRunning = false;

    if (STATE === "listen" && lastTranscript) {

      // ðŸ›¡ï¸ nur eine /ask pro Durchlauf
      if (askInProgress) return;
      askInProgress = true;

      // 1ï¸âƒ£ HMMM
      resetMovements();
      STATE = "hmmm";
      hmNeigen = true;
      hmStartTime = performance.now();
      speak("Ã„hm..... einen Moment", true);

      setTimeout(() => {

        fetch("/ask", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: lastTranscript })
        })
        .then(r => r.json())
        .then(data => {

          resetMovements();
          STATE = "answer";
          rising = true;
          riseStartTime = performance.now();

          fetch("/tts", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ text: data.answer })
          })
          .then(r => r.json())
          .then(dataTTS => {
            playAudioAndLipsync(dataTTS.audio, dataTTS.lipsync);
          })
          .catch(() => {
            speak(data.answer);
          });

          const waitUntilDone = setInterval(() => {
            if (!talking && !rising) {
              clearInterval(waitUntilDone);
              resetMovements();
              greeted = false;
              STATE = "idle";
              askInProgress = false;
              toIdlePose = true;
              toIdleStart = performance.now();
            }
          }, 200);

        })
        .catch(() => {
          askInProgress = false;
          resetMovements();
          STATE = "idle";
        });

      }, 4000);

    } else {
      resetMovements();
      STATE = "idle";
    }
  };
}

/* ===============================
   ðŸ›ï¸ MUSEUMS-RESET (Wake / Fokus)
================================ */

function museumReset(reason = "") {
  console.log("ðŸ›¡ï¸ Museum-Reset", reason);

  // ðŸ›¡ï¸ Wake-Guard: erster Klick nach Sleep wird ignoriert
  wakeGuard = true;
  setTimeout(() => {
    wakeGuard = false;
    console.log("ðŸŸ¢ Wake-Guard aufgehoben");
  }, 600);

  // ðŸ›¡ï¸ Wake-Stabilisierung: Recognition nach Sleep blocken
  wakeStabilizing = true;
  setTimeout(() => {
    wakeStabilizing = false;
    console.log("ðŸŸ¢ Wake stabilisiert");
  }, 1200);

  // --- Speech sauber abbrechen ---
  try {
    speechSynthesis.cancel();
  } catch (e) {}

  if (typeof recognition !== "undefined" && recognition && recRunning) {
    try {
      recognition.abort();
    } catch (e) {}
    recRunning = false;
  }

  // --- State Machine auf Urzustand ---
  STATE = "idle";
  greeted = false;
  talking = false;
  rising = false;
  hmNeigen = false;
  frontalFix = false;

  lastTranscript = "";
  justFinishedSpeaking = false;
  mouthCooldown = false;

  // Guards zurÃ¼cksetzen
  recognitionHandled = false;
  askInProgress = false;

  // --- Mund neutralisieren (VISEME) ---
  try {
    if (typeof setViseme === "function") {
      setViseme("M", 0);
    }
  } catch (e) {}

  // --- Kopf & Position neutral ---
  if (model) {
    model.position.y = baseY;
    model.rotation.x = baseRotX;
    model.rotation.y = baseRotY - Math.PI / 2;
  }
}


/* ===============================
   ðŸ” MUSEUMS-TRIGGER (Idle-only)
================================ */

document.addEventListener("visibilitychange", () => {
  if (!document.hidden && STATE === "idle" && !talking && !recRunning) {
    museumReset("visibilitychange");
  }
});

window.addEventListener("focus", () => {
  if (STATE === "idle" && !talking && !recRunning) {
    museumReset("focus");
  }
});


/* ===============================
   ðŸŽ¤ RECOGNITION START (SAUBER)
================================ */

function startRecognition() {

  if (recRunning) {
    console.warn("â—RECOGNITION BLOCKED â€” already running");
    return;
  }

  // ðŸ›¡ï¸ Guards fÃ¼r neuen Durchlauf zurÃ¼cksetzen
  recognitionHandled = false;
  askInProgress = false;

  resetMovements();
  lastTranscript = "";
  STATE = "listen";

  try {
    recognition.start();
    recRunning = true;
  } catch (e) {
    console.warn("â—Recognition start error:", e);
    recRunning = false;
  }
}

/* -----------------------------
   BUTTON â€“ GREET & LISTEN
----------------------------- */
document.getElementById("micBtn").onclick = () => {

  // ðŸ›¡ï¸ Wake-Guard: erster Klick nach Ruhemodus tut nichts
  if (wakeGuard) {
    console.log("â³ Klick ignoriert (Wake-Guard)");
    return;
  }

  // 1ï¸âƒ£ ERSTER KLICK â†’ BEGRÃœSSUNG
  if (!greeted) {
    resetMovements();
    greeted = true;
    STATE = "greet";

    frontalFix = false;
    rising = true;
    riseStartTime = performance.now();

    speak(
      "Seid gegrÃ¼ÃŸt, mein Freund. Ich bin Friedrich Barbarossa, nach fast neunhundert Jahren im Kaiserberg zu Lautern erwacht. Was ist Euer Begehr.",
      false
    );
    return;
  }

  // 2ï¸âƒ£ SPRACHERKENNUNG VERFÃœGBAR?
  if (!recognition) {
    alert("Spracherkennung wird von diesem Browser nicht unterstÃ¼tzt.");
    return;
  }

  // 3ï¸âƒ£ ERKENNUNG STARTEN (SAUBER GEKAPSELT)
  startRecognition();
};

/* -----------------------------
   1) MÃ„NNLICHE STIMME FEST SETZEN  (GLOBAL!)
----------------------------- */

let maleVoice = null;

function setMaleVoice() {
  const voices = speechSynthesis.getVoices();

  if (!voices.length) {
    setTimeout(setMaleVoice, 150);
    return;
  }

  maleVoice = voices.find(
    v => v.name === "Microsoft Stefan - German (Germany)"
  ) || null;

  console.log("AusgewÃ¤hlte Stimme:", maleVoice);
}

speechSynthesis.onvoiceschanged = setMaleVoice;
setMaleVoice();


/* --------------------------------
   HILFSFUNKTIONEN (ALLGEMEIN)
----------------------------------- */

// linearer Ãœbergang (wird z. B. fÃ¼r Animationen genutzt)
function lerp(a, b, t) {
  return a + (b - a) * t;
}

/* -----------------------------
   SPEAK â€“ FEINTUNING (VISEME)
----------------------------- */
function speak(text, slow = false) {

  const u = new SpeechSynthesisUtterance(text);
  u.lang = "de-DE";
  u.rate = slow ? 0.85 : 1.0;

  if (maleVoice) {
    u.voice = maleVoice;
  }

  let visemeTimer = null;
  let running = false;

  // Ruhige, wÃ¼rdige Viseme-Basis
  const cycle = ["A", "E", "O", "U"];
  let c = Math.floor(Math.random() * cycle.length);

  const stepMs = slow ? 220 : 180;

  function startVisemes() {
    if (running) return;
    if (!visemeMesh || !visemeMesh.morphTargetInfluences) return;

    running = true;

    visemeTimer = setInterval(() => {

      // ðŸ”¹ StÃ¤rke leicht variieren (vermeidet Robotik)
      const strength = 0.40 + Math.random() * 0.20; // 0.65â€“0.90
      setViseme(cycle[c], strength);

      // ðŸ”¹ Nicht jedes Mal wechseln â†’ natÃ¼rlicher
      if (Math.random() < 0.35) {
        c = (c + 1) % cycle.length;
      }

    }, stepMs);
  }

  function stopVisemes(close = true, pause = 180) {
    running = false;

    if (visemeTimer) {
      clearInterval(visemeTimer);
      visemeTimer = null;
    }

    if (close && visemeMesh && visemeMesh.morphTargetInfluences) {
      setViseme("M", 1);
      setTimeout(() => setViseme("M", 0), pause);
    }
  }

  /* -----------------------------
     START DES SPRECHENS
  ----------------------------- */
  u.onstart = () => {
    talking = true;
    mouthCooldown = false;
    justFinishedSpeaking = false;

    if (visemeMesh && visemeMesh.morphTargetInfluences) {
      setViseme("M", 0);
      startVisemes();
    }
  };

  /* -----------------------------
     SATZZEICHEN â†’ MUND ZU
  ----------------------------- */
  u.onboundary = e => {
    if (!e || typeof e.charIndex !== "number") return;
    if (!visemeMesh || !visemeMesh.morphTargetInfluences) return;

    const ch = text[e.charIndex];

    // weiche Pause
    if (",;:".includes(ch)) {
      stopVisemes(true, 160);
      setTimeout(startVisemes, 160);
    }

    // harte Pause / Satzende
    if (".!?".includes(ch)) {
      stopVisemes(true, 240);
    }
  };

  /* -----------------------------
     ENDE DES SPRECHENS
  ----------------------------- */
  u.onend = () => {
    stopVisemes(true, 220);

    talking = false;
    justFinishedSpeaking = true;
    mouthCooldown = true;

    setTimeout(() => {
      justFinishedSpeaking = false;
      mouthCooldown = false;
    }, 120);
  };

  speechSynthesis.speak(u);
}

/* -----------------------------
   RESIZE
----------------------------- */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
