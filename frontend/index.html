<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Frag Friedrich Barbarossa</title>

<link rel="icon" href="avatar.png" type="image/png">
<link rel="apple-touch-icon" href="avatar.png">
<meta name="theme-color" content="#000000">

<style>
  /* -----------------------------
     BODY & GRUNDLAYOUT
  ----------------------------- */
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: "Georgia", serif;
    color: white;
    height: 100vh;
  }

  /* -----------------------------
     CANVAS (Fullscreen-Hintergrund)
  ----------------------------- */
  #avatarCanvas {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    display: block;
    z-index: 1; /* Canvas Hintergrund */
  }

  /* -----------------------------
     √úBERSCHRIFT
  ----------------------------- */
  h1 {
    position: absolute;
    top: 20px;
    width: 100%;
    text-align: center;
    font-size: 2em;
    color: #e0b36b;
    animation: pulse 3s ease-in-out infinite;
    z-index: 10;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.85; }
  }

  /* -----------------------------
     MIKROFONBUTTON
  ----------------------------- */
  #micBtn {
    position: absolute;
    bottom: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: none;
    background: #222;
    color: white;
    font-size: 32px;
    cursor: pointer;
    z-index: 10;
  }

  #micBtn:hover { background: #444; }

  /* -----------------------------
     LOADING TEXT
  ----------------------------- */
  #loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ccc;
    font-size: 1.1em;
    text-align: center;
    z-index: 10;
  }

  /* -----------------------------
     FOOTER (unten zentriert, √ºber allem)
  ----------------------------- */
  footer {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    color: rgba(255, 255, 255, 0.6);
    text-align: center;
    pointer-events: none; /* wichtig bei Canvas + Klicks */
    z-index: 10000;       /* immer oben */
  }
</style>
</head>

<body>
<h1>Frag Friedrich</h1>
<div id="loading">Avatar wird geladen‚Ä¶</div>
<canvas id="avatarCanvas"></canvas>
<button id="micBtn">üé§</button>
<footer>
¬© 2025 Dr. Christoph Dammann
</footer>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
console.log("SCRIPT START");
  
/* ==========================================
   MUSEUM STARTUP CLEANUP ‚Äì SICHER & LOKAL
   ========================================== */

(function museumStartupCleanup() {
  try {
    console.log("[Museum] Startup cleanup begin");

    /* 1Ô∏è‚É£ Eigene Storage-Daten l√∂schen */
    try {
      localStorage.clear();
      sessionStorage.clear();
      console.log("[Museum] localStorage & sessionStorage cleared");
    } catch (e) {
      console.warn("[Museum] Storage clear failed:", e);
    }

    /* 2Ô∏è‚É£ IndexedDB vollst√§ndig l√∂schen (Speech / Media-Reste) */
    if (window.indexedDB && indexedDB.databases) {
      indexedDB.databases().then(dbs => {
        dbs.forEach(db => {
          if (db.name) {
            indexedDB.deleteDatabase(db.name);
            console.log("[Museum] IndexedDB deleted:", db.name);
          }
        });
      });
    }

    /* 3Ô∏è‚É£ Service Worker entfernen (falls jemals vorhanden) */
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs => {
        regs.forEach(reg => {
          reg.unregister();
          console.log("[Museum] ServiceWorker unregistered");
        });
      });
    }

    /* 4Ô∏è‚É£ Harte Reset-Flags f√ºr Avatar-Logik */
    window.__MUSEUM_RESET__ = true;

    console.log("[Museum] Startup cleanup done");
  } catch (err) {
    console.error("[Museum] Startup cleanup error:", err);
  }
})();

/* ===============================
   STATE-DEFINITION + VARIABLEN
================================ */

// === VISEME-STATE ===
let visemeMesh = null;   // wird im GLTF-Loader gesetzt

// === Audio / Analyse (Reserve) ===
let audioCtx, analyser, src;

// === ZENTRALE ZUSTANDSMASCHINE ===
// Erlaubte Zust√§nde:
// "sleep"   ‚Üí Bildschirm war dunkel / gerade aufgeweckt
// "idle"    ‚Üí wach, bereit
// "greet"   ‚Üí Begr√º√üung l√§uft
// "listen"  ‚Üí Aufnahme l√§uft
// "answer"  ‚Üí Antwort l√§uft

let STATE = "idle";

// === Kern-Flags ===
let model = null;
let lastTranscript = "";
let greeted = false;
let talking = false;
let recRunning = false;
let runId = 0;          // üîí eindeutiger Durchlaufz√§hler
let listeningFinished = false;
let buttonLocked = false;
let mouthCooldown = false;


// === Bewegungszust√§nde ===
let frontalFix = true;
let hmNeigen = false;
let rising = false;
let hmStartTime = 0;
let riseStartTime = 0;

// === R√ºckkehr in Ruhepose (nur am Ende!) ===
let toIdlePose = false;
let toIdleStart = 0;
const toIdleDuration = 3000;

// === Animationszeiten (ms) ===
const hmDuration = 8000;
const riseDuration = 3000;

// === Grundposition Avatar ===
let baseRotY = -0.35;
let baseRotX = 0.25;
let baseY = 0;

// === RESET ALLER BEWEGUNGEN (hart, eindeutig) ===
function resetMovements() {
  hmNeigen = false;
  rising = false;
  toIdlePose = false;
  talking = false;
}

/* -----------------------------
   THREE.js SETUP
----------------------------- */

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  30,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 2.8);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("avatarCanvas"),
  antialias: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setClearColor(0x000000);

/* -----------------------------
   LICHT
----------------------------- */
const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(1, 1, 2);
scene.add(dirLight);

const ambLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambLight);

const frontLight = new THREE.PointLight(0xffffff, 0.8);
frontLight.position.set(0, 0.5, 2);
scene.add(frontLight);

/* -----------------------------
   MODEL + VISEME
----------------------------- */

// globale Referenz (State-Machine nutzt sie)
visemeMesh = null;

// feste Indizes aus Blender
const visemeIndex = {
  A: 0,
  E: 1,
  O: 2,
  U: 3,
  M: 4
};

const loader = new THREE.GLTFLoader();
loader.load("./avatar.glb", gltf => {

  model = gltf.scene;
  scene.add(model);

  // Viseme-Mesh finden
  visemeMesh = null;
  model.traverse(obj => {
    if ((obj.isMesh || obj.isSkinnedMesh) && obj.morphTargetDictionary) {
      console.log("‚úî Viseme-Tr√§ger gefunden:", obj.name, obj.morphTargetDictionary);
      if (!visemeMesh) visemeMesh = obj;
    }
  });

  if (!visemeMesh) {
    console.error("‚ùå KEIN Viseme-Mesh gefunden ‚Äì GLB pr√ºfen!");
  }

  // Ladeanzeige aus
  const loadingEl = document.getElementById("loading");
  if (loadingEl) loadingEl.style.display = "none";

  // Animation exakt einmal starten
  animate();
});

/* -----------------------------
   VISEME ‚Äì NIEDRIGE EBENE
   (keine Logik, kein State)
----------------------------- */
function setViseme(key, value) {
  if (!visemeMesh || !visemeMesh.morphTargetInfluences) return;

  const idx = visemeIndex[key];
  if (idx === undefined) return;

  // alle schlie√üen
  visemeMesh.morphTargetInfluences.fill(0);

  // Ziel setzen
  visemeMesh.morphTargetInfluences[idx] = value;
}

// ====================================
// ANIMATE ‚Äì FINAL & STABIL (VISEME-KLON)
// ====================================
function animate() {
  requestAnimationFrame(animate);
  if (!model) return;

  const now = performance.now();
  const frontalY = -Math.PI / 2;
  const rightY   = baseRotY - Math.PI / 2;
  const leftY    = frontalY + 0.25;

  /* ===============================
     üõë MOUTH-COOLDOWN (H√ñCHSTE PRIORIT√ÑT)
     ‚Üí verhindert Nachklappern
  =============================== */
  if (mouthCooldown) {
    setViseme("M", 0);
  }

  /* ===============================
     üßä Mund neutral, wenn nicht gesprochen wird
     (NUR wenn KEIN Cooldown aktiv)
  =============================== */
  if (!mouthCooldown && !talking && STATE !== "think") {
    setViseme("M", 0);
  }

  /* ===============================
     THINK-PHASE ‚Üí HMMM / NEIGEN
     (H√ñCHSTE PRIORIT√ÑT F√úR KOPF)
  =============================== */
  if (STATE === "think" && hmNeigen) {
    model.rotation.x = THREE.MathUtils.lerp(
      model.rotation.x,
      baseRotX + 0.25,
      0.04
    );
    model.rotation.y = THREE.MathUtils.lerp(
      model.rotation.y,
      leftY,
      0.04
    );

    renderer.render(scene, camera);
    return; // ‚õî nichts darf dar√ºber hinwegzeichnen
  }

  /* ===============================
     GREET / ANSWER ‚Üí FRONTAL
  =============================== */
  if (rising) {
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.06);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.06);
  }

  /* ===============================
     TALKING / LISTEN
  =============================== */
  else if (talking || STATE === "listen" || STATE === "greet") {
    model.position.y = baseY + Math.sin(now * 0.0015) * 0.008;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, frontalY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, 0, 0.03);
  }

  /* ===============================
     IDLE ‚Üí SANFT NACH RECHTS
     + ü´Å ATEM (KOPF / BODY)
  =============================== */
  else if (STATE === "idle" && !recRunning && !talking) {

    // ü´Å sehr langsame Atembewegung (hoch / runter)
    const breath = Math.sin(now * 0.0019) * 0.006; // ~ ¬±2 mm

    model.position.y = baseY + breath;
    model.rotation.y = THREE.MathUtils.lerp(model.rotation.y, rightY, 0.03);
    model.rotation.x = THREE.MathUtils.lerp(model.rotation.x, baseRotX, 0.03);
  }

  /* ===============================
     DRIFT (NUR WENN NICHT THINK)
  =============================== */
  if (STATE !== "think") {
    const driftX = Math.sin(now * 0.0004) * 0.015;
    const driftY = Math.sin(now * 0.0003) * 0.012;

    model.rotation.x = THREE.MathUtils.lerp(
      model.rotation.x,
      baseRotX + driftX,
      0.02
    );

    const baseYaw = (STATE === "idle") ? rightY : frontalY;
    model.rotation.y = THREE.MathUtils.lerp(
      model.rotation.y,
      baseYaw + driftY,
      0.02
    );
  }

  renderer.render(scene, camera);
}

/* -----------------------------
   STATE MACHINE ‚Äì RECOGNITION
   MIT THINK-PHASE (WAKE-SICHER)
----------------------------- */

let recognition = null;
let heardSomething = false;

/* -----------------------------
   Recognition sauber initialisieren
----------------------------- */
function initRecognition() {
  if (!("webkitSpeechRecognition" in window)) return;

  recognition = new webkitSpeechRecognition();
  recognition.lang = "de-DE";
  recognition.continuous = false;
  recognition.interimResults = false;

  heardSomething = false;

  recognition.onresult = (e) => {
    if (STATE !== "listen") return;

    const res = e.results[0][0].transcript;
    if (!res || res.trim().length < 2) return;

    lastTranscript = res;
    heardSomething = true;
  };

  recognition.onend = () => {
    recRunning = false;

    // ‚ùó Kein Think-Phase-Trigger, wenn nicht wirklich geh√∂rt wurde
    if (STATE !== "listen") return;
    if (!heardSomething || !lastTranscript) {
      STATE = "idle";
      return;
    }

    /* ===============================
       THINK-PHASE
    =============================== */

    STATE = "think";
    resetMovements();

    // üß† Think-Bewegung einen Frame verz√∂gert setzen
    requestAnimationFrame(() => {
      hmNeigen = true;
      hmStartTime = performance.now();
    });

    // üó£Ô∏è Denkphrase
    speak("√Ñhm ‚Ä¶ einen Moment bitte.", true);

    /* ===============================
       FRAGE ‚Üí SERVER ‚Üí ANTWORT
       (erst NACH Think-Phase)
    =============================== */

    fetch("/ask", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: lastTranscript })
    })
    .then(r => r.json())
    .then(data => {

      const waitForThinkEnd = setInterval(() => {
        if (!talking) {
          clearInterval(waitForThinkEnd);

          STATE = "answer";
          resetMovements();

          rising = true;
          riseStartTime = performance.now();

          speak(data.answer);
        }
      }, 120);

    })
    .catch(() => {
      STATE = "answer";
      resetMovements();
      speak("Verzeiht, ich habe Euch nicht recht verstanden.");
    });

  }; // ‚úÖ recognition.onend geschlossen
}    // ‚úÖ initRecognition geschlossen


/* -----------------------------
   BUTTON ‚Äì GREET & LISTEN (FINAL)
----------------------------- */

const micBtn = document.getElementById("micBtn");

micBtn.onclick = () => {

  // üîí Button-Guard gegen Doppelklicks
  if (buttonLocked) return;
  buttonLocked = true;
  setTimeout(() => buttonLocked = false, 400);

  /* ===============================
     1Ô∏è‚É£ IDLE ‚Üí GREET
  =============================== */
  if (STATE === "idle" && !greeted) {
    greeted = true;
    STATE = "greet";

    resetMovements();

    frontalFix = false;
    rising = true;
    riseStartTime = performance.now();

    // üîÅ Wake-sicher: alte Recognition hart verwerfen
    try {
      if (recognition) recognition.abort();
    } catch (e) {}
    recRunning = false;
    listeningFinished = false;

    speak(
      "Seid gegr√º√üt, mein Freund. Ich bin Friedrich Barbarossa, nach fast neunhundert Jahren im Kaiserberg zu Lautern erwacht. Was ist Euer Begehr?",
      false
    );
    return;
  }

  /* ===============================
     2Ô∏è‚É£ GREET ‚Üí LISTEN
  =============================== */
  if (STATE === "greet" && !recRunning) {
    if (!("webkitSpeechRecognition" in window)) {
      alert("Spracherkennung wird von diesem Browser nicht unterst√ºtzt.");
      return;
    }

    initRecognition();

    lastTranscript = "";
    listeningFinished = false;
    STATE = "listen";

    try {
      recognition.start();
      recRunning = true;
    } catch (e) {
      recRunning = false;
      STATE = "idle";
    }
    return;
  }

  /* ===============================
     3Ô∏è‚É£ LISTEN
     (kein explizites Stop mehr n√∂tig)
  =============================== */
  if (STATE === "listen") {
    // Klick w√§hrend Aufnahme wird ignoriert
    return;
  }

  /* ===============================
     ALLES ANDERE ‚Üí IGNORIEREN
  =============================== */
};

/* ===============================
   RECOGNITION START
================================ */

function startRecognition() {
  // absichtlich leer
}


/* ===============================
   üèõÔ∏è MUSEUMS-RESET (PASSIV & SICHER)
================================ */

function museumReset(reason = "") {
  console.log("üõ°Ô∏è Museum-Reset:", reason);

  // ‚ùå Niemals w√§hrend aktiver Nutzung eingreifen
  if (STATE !== "idle" || talking || recRunning) {
    console.log("‚õî Reset abgebrochen ‚Äì System aktiv");
    return;
  }

  // --- Speech sicher beenden ---
  try {
    speechSynthesis.cancel();
  } catch (e) {}

  // --- Recognition hart beenden & verwerfen ---
  try {
    if (recognition) recognition.abort();
  } catch (e) {}
  recRunning = false;
  recognition = null;

  // --- Bewegungen vollst√§ndig neutralisieren ---
  resetMovements();

  // --- Transcript l√∂schen ---
  lastTranscript = "";

  // --- Viseme neutral ---
  try {
    if (typeof setViseme === "function") {
      setViseme("M", 0);
    }
  } catch (e) {}

  // --- Avatar in definierte Ruhepose ---
  if (model) {
    model.position.y = baseY;
    model.rotation.x = baseRotX;
    model.rotation.y = baseRotY - Math.PI / 2;
  }

  console.log("üü¢ Museum-Reset abgeschlossen");
}

/* ===============================
   üîÅ MUSEUMS-TRIGGER
   (NUR BILDSCHIRM WEG / ZUR√úCK)
================================ */

// Reagiert nur auf echtes "Tab verborgen"
document.addEventListener("visibilitychange", () => {
  if (
    document.hidden &&
    STATE === "idle" &&
    !talking &&
    !recRunning
  ) {
    museumReset("visibilitychange");
  }
});

  /* ===============================
   üéôÔ∏è VOICE SETUP (MUSEUMSSTABIL)
================================ */

let maleVoice = null;

function setMaleVoice() {
  try {
    const voices = speechSynthesis.getVoices();
    if (!voices || !voices.length) return;

    // bevorzugt: Microsoft Stefan (de-DE), sonst irgendeine de-DE Stimme
    maleVoice =
      voices.find(v => v.lang === "de-DE" && v.name.toLowerCase().includes("stefan")) ||
      voices.find(v => v.lang === "de-DE") ||
      null;

    if (maleVoice) {
      console.log("üéôÔ∏è Ausgew√§hlte Stimme:", maleVoice);
    } else {
      console.warn("‚ö†Ô∏è Keine passende de-DE Stimme gefunden ‚Äì Standardstimme wird genutzt");
    }
  } catch (e) {
    console.warn("‚ö†Ô∏è setMaleVoice Fehler:", e);
    maleVoice = null;
  }
}

// Chrome/Edge: Stimmen werden oft asynchron geladen
speechSynthesis.onvoiceschanged = setMaleVoice;

// sofortiger Versuch (falls Stimmen schon da sind)
setMaleVoice();
/* -----------------------------
   SPEAK ‚Äì FINAL (VISEME-STABIL)
----------------------------- */
function speak(text, slow = false) {

  const u = new SpeechSynthesisUtterance(text);
  u.lang = "de-DE";
  u.rate = slow ? 0.85 : 1.0;
  if (typeof maleVoice !== "undefined" && maleVoice) {
    u.voice = maleVoice;
  }

  const isGreeting = (STATE === "greet");

  let timer = null;
  let active = false;
  let preEndTimer = null;

  const stepMs = slow ? 135 : 95;
  const lerpFactor = 0.42;
  const baseClose = 0.04;

  /* -----------------------------
     HARTER STOP ‚Üí RUHE
  ----------------------------- */
  function hardStopToRest() {
    active = false;

    if (timer) {
      clearInterval(timer);
      timer = null;
    }

    if (!visemeMesh || !visemeMesh.morphTargetInfluences) return;

    visemeMesh.morphTargetInfluences.fill(0);
    visemeMesh.morphTargetInfluences[visemeIndex.M] = baseClose;
  }

  function chooseNextViseme() {
    const r = Math.random();
    if (r < 0.42) return "A";
    if (r < 0.68) return "U";
    if (r < 0.84) return "E";
    return "O";
  }

  function startVisemes() {
    if (active || !visemeMesh || !visemeMesh.morphTargetInfluences) return;

    active = true;
    let targetIdx = visemeIndex[chooseNextViseme()];

    timer = setInterval(() => {
      if (!active) return;

      if (Math.random() < 0.5) {
        targetIdx = visemeIndex[chooseNextViseme()];
      }

      let target = 0.5 + Math.random() * 0.2;

      const key = Object.keys(visemeIndex)
        .find(k => visemeIndex[k] === targetIdx);

      if (key === "O") target *= 0.65;
      if (key === "E") target *= 0.75;

      const inf = visemeMesh.morphTargetInfluences;
      for (let i = 0; i < inf.length; i++) {
        const desired = (i === targetIdx) ? target : baseClose;
        inf[i] += (desired - inf[i]) * lerpFactor;
      }
    }, stepMs);
  }

  /* -----------------------------
     GROBE DAUER-SCH√ÑTZUNG
     (f√ºr Pre-End-Stop)
  ----------------------------- */
  function estimateSpeechDurationMs(text, slow) {
    const charsPerSecond = slow ? 8 : 12; // bew√§hrter Desktop-Chrome-Wert
    return (text.length / charsPerSecond) * 1000;
  }

  /* -----------------------------
     START
  ----------------------------- */
  u.onstart = () => {
    talking = true;
    hardStopToRest();
    startVisemes();

    // üõë Pre-End-Stop: Mund ca. 0,5 s vor Audioende schlie√üen
    const PRE_END_STOP_MS = 500;
    const estimated = estimateSpeechDurationMs(text, slow);

    preEndTimer = setTimeout(() => {
      hardStopToRest();
    }, Math.max(0, estimated - PRE_END_STOP_MS));
  };

  /* -----------------------------
     SATZZEICHEN
  ----------------------------- */
  u.onboundary = e => {
    if (isGreeting) return;
    if (!active || !e || typeof e.charIndex !== "number") return;

    const ch = text[e.charIndex];

    if (",;:".includes(ch)) {
      active = false;
      setTimeout(() => startVisemes(), 90);
    }

    if (".!?".includes(ch)) {
      active = false;
    }
  };

  /* -----------------------------
     ENDE ‚Äì ABSOLUTER SCHLUSS
     + MOUTH-COOLDOWN GEGEN NACHKLAPPERN
  ----------------------------- */
  u.onend = () => {
    if (preEndTimer) {
      clearTimeout(preEndTimer);
      preEndTimer = null;
    }

    hardStopToRest();
    talking = false;

    // üõë kurzer Mund-Cooldown (f√§ngt letzte Frames ab)
    mouthCooldown = true;
    setTimeout(() => {
      mouthCooldown = false;
    }, 120);

    if (STATE === "answer") {
      resetMovements();
      greeted = false;
      hmNeigen = false;
      rising = false;
      STATE = "idle";
    }
  };

  // Start der Sprachausgabe
  speechSynthesis.speak(u);
}
/* -----------------------------
   RESIZE
----------------------------- */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
